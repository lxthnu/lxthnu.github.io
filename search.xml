<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RDMA基本服务类型</title>
      <link href="/posts/9078.html"/>
      <url>/posts/9078.html</url>
      
        <content type="html"><![CDATA[<p>🐱PS：</p><p>本文是对该博客（<a href="https://zhuanlan.zhihu.com/p/144099636">https://zhuanlan.zhihu.com/p/144099636</a>）的一个学习笔记。</p><p>若考虑使用哪种服务类型的QP，指路：<a href="https://www.rdmamojo.com/2013/06/01/which-queue-pair-type-to-use/">https://www.rdmamojo.com/2013/06/01/which-queue-pair-type-to-use/</a></p><h1 id="可靠服务"><a href="#可靠服务" class="headerlink" title="可靠服务"></a>可靠服务</h1><p>IB协议中是这样描述可靠服务的：可靠服务在发送和接受者之间保证了信息最多只会传递一次，并且能够保证其按照发送顺序被接收。</p><p>IB通过以下三个机制来保证可靠性：</p><ul><li>在IB协议的可靠服务类型中，使用了<strong>应答机制</strong>来保证数据包被对方收到。即接收端在接收到数据包后返回ACK。IB的可靠服务类型中，接收方不是每一个包都必须回复，也可以一次回复多个包的ACK。</li><li>IB协议使用CRC进行<strong>数据校验</strong>。发端会对Header和Payload（有效载荷，也就是真正要收发的数据）通过一定的算法得到一个校验值放到数据包的末尾。对端收到数据包后，也会用相同的算法计算出校验值，然后与数据包中的校验值比对，如果不一致，说明数据中包含错误（一般是链路问题导致的），那么接收端就会丢弃这个数据包。</li><li>IB协议中有PSN（Packet Sequence Number，包序号）进行<strong><strong>保序</strong></strong>，即每个包都有一个递增的编号。PSN可以用来检测是否丢包，比如收端收到了1，但是在没收到2的情况下就收到了3，那么其就会认为传输过程中发生了错误，之后会回复一个NAK给发端，让其重发丢失的包。<ul><li>PSN是每个QP都具有的，不同QP间是相互独立的。</li></ul></li></ul><blockquote><p>ICRC 校验发生在IB链路层, 而NAK是IB 传输层的功能。NAK会发生，但是发生在下一个packet (with no ICRC error)。比如，PSN为10的数据包在传输到响应方时出现了某种损坏，由于ICRC错误，响应方IB链路层将会丢弃该数据包。这时IB 传输层 会看到 PSN&#x3D;9 后面跟着 PSN&#x3D;11。PSN&#x3D;11 会触发IB传输层发起NAK。</p></blockquote><aside>💡 标准的IB规范不会等待重新排序。比如，PSN=2发生错误被丢弃，当PSN=3收到时，IB 传输层马上就会发起一个NAK（PSN=2），并不会花时间等2。</aside><aside>💡 CRC是硬件完成的，CPU不参与报文处理。对于Soft-RoCE和Soft-iWARP来说，它们的CRC校验只能由CPU来完成，这对性能影响很大。</aside><aside>💡 CRC保证的是单个报文的正确性，当底层将大数据进行拆包时，需要对每一个小包进行计算。</aside><h1 id="不可靠服务"><a href="#不可靠服务" class="headerlink" title="不可靠服务"></a>不可靠服务</h1><p>没有上述这些机制来保证数据包被正确的接收，属于“发出去就行，我不关心有没有被收到”的服务类型。</p><h1 id="基于连接的服务"><a href="#基于连接的服务" class="headerlink" title="基于连接的服务"></a>基于连接的服务</h1><p>每个QP都和另一个远端节点相关联。在这种情况下，QP Context（简称QPC）中包含有远端节点的QP信息。在建立通信的过程中，两个节点会交换包括稍后用于通信的QP在内的对端信息。<strong>在连接服务类型中的每个QP，都和唯一的另一个QP建立了连接，</strong>也就是说QP下发的每个WQE的目的地都是唯一的。</p><h1 id="基于数据报的服务"><a href="#基于数据报的服务" class="headerlink" title="基于数据报的服务"></a>基于<strong>数据报</strong>的服务</h1><p>与连接相反，发端和收端间不需要“建立管道”的步骤，只要发端到收端物理上是可以到达的，那么我就可能从任何路径发给任意的收端节点。</p><ul><li><p>IB协议对其的定义是这样的：</p><p>对于数据报服务来说，QP不会跟一个唯一的远端节点绑定，而是<strong>通过WQE来指定目的节点</strong>。和连接类型的服务一样，建立通信的过程也需要两端交换对端信息，但是数据报服务对于每个目的节点都需要执行一次这个交换过程。</p></li></ul><p>比如，在数据报类型的QP的Context中，不包含对端信息，即每个QP不跟另一个QP绑定。QP下发给硬件的<strong>每个WQE</strong>都可能<strong>指向不同的目的地</strong>。与连接服务类型一样，本端QP可以和哪个对端QP发送数据，是在准备阶段提前通过某些方式相互告知的。这也是上文“数据报服务对于每个目的节点都需要执行一次这个交换过程”的含义。</p><aside>💡 在基于连接的服务中，一对一连接需要存储更多的context或data以维持一对一连接状态，但数据报不需要存储那么多的数据。不过连接可以做到bypass CPU，但数据报不能bypass CPU。</aside><h1 id="RC"><a href="#RC" class="headerlink" title="RC"></a>RC</h1><p>基于连接的可靠服务，类比TCP&#x2F;IP协议栈传输层的TCP。</p><p>RC用于对数据完整性和可靠性要求较高的场景，跟TCP一样，因为需要各种机制来保证可靠，所以开销自然会大一些。</p><p>由于RC服务类型和每个节点间需要各自维护一个QP，假设有N个节点要相互通信，那么至少需要**N * (N - 1)**个QP，而QP和QPC本身是需要占用网卡资源或者内存的，当节点数很多时，存储资源消耗将会非常大。</p><h1 id="UC"><a href="#UC" class="headerlink" title="UC"></a>UC</h1><p>基于连接的不可靠服务。</p><ul><li><p>注意UC支持WRITE却不支持READ操作</p><blockquote><p>因为read需要请求端网卡保存上下文等信息（比如保存一些状态以等待某个发出去的READ返回数据），如果是不可靠的话，<strong>包丢失会造成网卡永久等待READ返回</strong>，这种行为不太符合常理，因此不可靠连接无法支持READ；</p></blockquote></li></ul><h1 id="RD"><a href="#RD" class="headerlink" title="RD"></a>RD</h1><p>基于数据报的可靠服务。各厂商选择实现是否支持该服务。</p><h1 id="UD"><a href="#UD" class="headerlink" title="UD"></a>UD</h1><p>基于数据报的不可靠服务，类比TCP&#x2F;IP协议栈传输层的UDP。</p><p>UD硬件开销小并且节省存储资源，比如N个节点需要相互通信，只需要创建<strong>N</strong>个QP就可以了，但是可靠性跟UDP一样没法保证。用户如果想基于UD服务类型实现可靠性，那么需要自己基于IB传输层实现应用层的可靠传输机制。</p><ul><li><p>注意UD不支持WRITE操作，只能用于SEND</p><blockquote><p>无论是可靠连接还是不可靠连接，都要求QP一对一连接（即文中的“建立管道”），也就是说READ和WRITE都需要一对一连接，但数据报无需一对一连接，因此没有一对一连接这个前提，所以无法支持WRITE</p></blockquote></li></ul><h1 id="各服务类型支持的操作"><a href="#各服务类型支持的操作" class="headerlink" title="各服务类型支持的操作"></a>各服务类型支持的操作</h1><p><img src="/img/4pic.png" alt="Untitled"></p><h1 id="一些问题及回答"><a href="#一些问题及回答" class="headerlink" title="一些问题及回答"></a>一些问题及回答</h1><p>如果一个qp占用了某udp src port，同一机器上的非rdma 的 udp程序还能用这个udp 源端口号吗？</p><blockquote><p>可以复用，IB规范对这个UDP Source Port没有做规定，一般是用这个域段做链路间的负载均衡。有的厂商通过驱动里做HASH得出一个值然后配到了硬件里，有的厂商甚至都没有做，估计是个随机值或者固定值。</p></blockquote><p>rdma中rc和ud能否拥有相同的qp number，网卡驱动根据qp type进行区分？</p><blockquote><p>不可以。这不止是修改驱动的问题，从API、整个RDMA软件栈和硬件实现来看，QP类型和QPN都是QP的固有属性之一，QP类型不同，调用API时传递的参数、软件栈的处理、QPC&#x2F;WQE的布局、硬件的处理都会有差异。虽然理论上可以这么搞，但是代价是破坏了一个成熟的标准，相当于自己重新定义了一种协议。</p></blockquote><p>RC和UD它们的具体应用场景是在哪里？</p><blockquote><p>RC用在对可靠性要求较高的场景，但是因为需要建立很多QP来维持进程间的连接，所以对内存的消耗很大。使用UD的话，每个进程只需要保留一个QP就可实现对整个组网内的其他进程通信，但是可靠性需要由上层保证。此外还有一种XRC服务，相比于RC可以节省通信所需的QP数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> RDMA学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RDMA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装linux内核教程</title>
      <link href="/posts/2366.html"/>
      <url>/posts/2366.html</url>
      
        <content type="html"><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装所需依赖包</span></span><br><span class="line">sudo apt install build-essential libncurses5-dev fakeroot xz-utils</span><br><span class="line">sudo apt install flex libdaemon-dev libbison-dev libelf-dev</span><br><span class="line">sudo apt-get install libssl-dev</span><br><span class="line">sudo apt-get install dwarves</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去官网下载你想要安装的内核版本，然后解压到/lib/modules目录下</span></span><br><span class="line"><span class="built_in">cd</span> 内核源码文件夹</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建内核配置文件</span></span><br><span class="line">sudo make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译内核源码</span></span><br><span class="line">sudo make -j16</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内核模块安装</span></span><br><span class="line">sudo make modules_install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内核安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝原来的内核配置文件</span></span><br><span class="line">sudo <span class="built_in">cp</span> /boot/config-`<span class="built_in">uname</span> -r`* .config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置内核</span></span><br><span class="line">sudo make defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译内核并安装</span></span><br><span class="line">sudo make -j$(<span class="built_in">nproc</span>)</span><br><span class="line">sudo make modules_install install</span><br></pre></td></tr></table></figure><blockquote><p>ps：方法一和方法二我都试过，可以成功安装</p></blockquote><p><strong>记录一下安装内核处理过的错误：</strong></p><p><a href="https://blog.csdn.net/m0_47696151/article/details/121574718">(111条消息) 编译内核报错 No rule to make target ‘debian&#x2F;canonical-certs.pem‘ 或 ‘canonical-revoked-certs.pem‘ 的解决方法_lylhw13_的博客-CSDN博客</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo scripts/config --<span class="built_in">disable</span> SYSTEM_TRUSTED_KEYS</span><br><span class="line">sudo scripts/config --<span class="built_in">disable</span> SYSTEM_REVOCATION_KEYS</span><br><span class="line">sudo make <span class="comment"># sudo make V=1 all</span></span><br></pre></td></tr></table></figure><p><strong>参考</strong>：</p><p><a href="https://blog.csdn.net/SweeNeil/article/details/83684565">https://blog.csdn.net/SweeNeil/article/details/83684565</a><br><a href="https://blog.csdn.net/qq_42793254/article/details/103074998">https://blog.csdn.net/qq_42793254/article/details/103074998</a></p><h1 id="切换内核版本"><a href="#切换内核版本" class="headerlink" title="切换内核版本"></a>切换内核版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看可用内核信息</span></span><br><span class="line">grep menuentry /boot/grub/grub.cfg </span><br><span class="line"></span><br><span class="line">sudo vim /etc/default/grub</span><br><span class="line"><span class="comment"># 写入GRUB_DEFAULT=&quot;Advanced options for Ubuntu &gt; Ubuntu, with Linux 4.18.0-18-generic&quot;</span></span><br><span class="line"><span class="comment"># 其中Linux 4.18.0-18-generic为你想切换到的版本</span></span><br><span class="line"></span><br><span class="line">sudo update-grub </span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后重启电脑 </span></span><br><span class="line">sudo reboot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前内核版本</span></span><br><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> linux内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源项目toktik环境搭建</title>
      <link href="/posts/9673.html"/>
      <url>/posts/9673.html</url>
      
        <content type="html"><![CDATA[<p>项目地址🎶：<a href="https://github.com/Toktik-Team/toktik/blob/main/README_zh-CN.md">https://github.com/Toktik-Team/toktik/blob/main/README_zh-CN.md</a></p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>ubuntu18.04  | 内核版本：Linux5.15.1</p><h1 id="linux下安装go1-19"><a href="#linux下安装go1-19" class="headerlink" title="linux下安装go1.19"></a>linux下安装go1.19</h1><p>注意：该项目不支持go1.21.0版本！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在/usr/local目录下载安装包 </span></span><br><span class="line">sudo wget https://go.dev/dl/go1.19.linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 在/usr/local目录下进行解压</span></span><br><span class="line">sudo tar -C /usr/local -xzf go1.19.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">vim ~/.profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在profile文件中添加代理和环境变量</span></span><br><span class="line"><span class="built_in">export</span> GOPROXY=https://goproxy.cn</span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/app/go </span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/go/bin:<span class="variable">$GOPATH</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装项目所需包</span></span><br><span class="line">go install github.com/cloudwego/kitex/tool/cmd/kitex@latest</span><br><span class="line">go install github.com/cloudwego/thriftgo@latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试是否安装成功</span></span><br><span class="line">kitex --versio</span><br><span class="line">thriftgo --version</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="linux下安装FFmpeg"><a href="#linux下安装FFmpeg" class="headerlink" title="linux下安装FFmpeg"></a>linux下安装FFmpeg</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install FFmpeg</span><br></pre></td></tr></table></figure><h1 id="linux下安装PostgreSQL"><a href="#linux下安装PostgreSQL" class="headerlink" title="linux下安装PostgreSQL"></a>linux下安装PostgreSQL</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install postgresql</span><br></pre></td></tr></table></figure><h1 id="linux下安装Redis"><a href="#linux下安装Redis" class="headerlink" title="linux下安装Redis"></a>linux下安装Redis</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install redis-server</span><br></pre></td></tr></table></figure><h1 id="linux下安装OpenTelemetry-Collector"><a href="#linux下安装OpenTelemetry-Collector" class="headerlink" title="linux下安装OpenTelemetry Collector"></a>linux下安装OpenTelemetry Collector</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo wget https://github.com/open-telemetry/opentelemetry-collector-releases/releases/download/v0.84.0/otelcol_0.84.0_linux_amd64.deb</span><br><span class="line"></span><br><span class="line">sudo dpkg -i otelcol_0.84.0_linux_amd64.deb</span><br><span class="line"></span><br><span class="line">./ocb_0.44.0_linux_amd64 --config=<span class="string">&quot;./otel-config.yaml&quot;</span></span><br></pre></td></tr></table></figure><h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装其它依赖包</span></span><br><span class="line">sudo apt install libavcodec-dev libavformat-dev libswscale-dev libavutil-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建所有服务</span></span><br><span class="line"><span class="built_in">cd</span> toktik</span><br><span class="line">sudo ./build-all.sh</span><br></pre></td></tr></table></figure><p>然后就可以运行项目啦~</p>]]></content>
      
      
      <categories>
          
          <category> 研一调研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux内存管理模块一些函数介绍</title>
      <link href="/posts/35092.html"/>
      <url>/posts/35092.html</url>
      
        <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>本文介绍了internal_get_user_pages_fast、gup_pgd_range、gup_pte_range、try_grab_compound_head</p><h1 id="internal-get-user-pages-fast"><a href="#internal-get-user-pages-fast" class="headerlink" title="internal_get_user_pages_fast"></a>internal_get_user_pages_fast</h1><p>这是一个用于获取用户空间页面的函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">internal_get_user_pages_fast</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">int</span> nr_pages,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> gup_flags,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> page **pages)</span></span><br></pre></td></tr></table></figure><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul><li><code>start</code>：要获取的用户空间起始地址。</li><li><code>nr_pages</code>：要获取的页面数量。</li><li><code>gup_flags</code>：用于指定页面特性和行为的标志。</li><li><code>pages</code>：指向一个<code>struct page</code>指针的数组，存储获取到的页面的指针。</li></ul><p>函数返回获取到的页面数量，或者在出错时返回负的错误代码。</p><h3 id="函数的主要步骤如下："><a href="#函数的主要步骤如下：" class="headerlink" title="函数的主要步骤如下："></a>函数的主要步骤如下：</h3><ol><li>进行参数检查，确保传入的<code>gup_flags</code>是合法的组合。</li><li>如果设置了<code>FOLL_PIN</code>标记，将当前进程的内存管理结构中的<code>has_pinned</code>原子变量设为1。</li><li>如果没有设置<code>FOLL_FAST_ONLY</code>标记，使用<code>might_lock_read</code>宏提示可能会对<code>mmap_lock</code>读锁进行加锁。</li><li>计算起始地址、结束地址和地址范围长度，确保它们是有效的。</li><li>禁用中断，阻止页面表页面在操作期间被释放。</li><li>如果启用了<code>CONFIG_HAVE_FAST_GUP</code>配置，并且允许快速GUP（Get User Pages）操作，则调用<code>gup_pgd_range</code>函数获取页面，将获取到的页面数量存储在<code>nr_pinned</code>变量中。</li><li>如果没有获取到所有请求的页面并且没有设置<code>FOLL_FAST_ONLY</code>标记，则尝试使用<code>__gup_longterm_unlocked</code>函数获取剩余的页面。</li><li>根据已获取页面的数量和剩余页面尝试的结果，返回最终结果。</li></ol><p>这个函数的主要作用是尝试使用快速GUP（Get User Pages）方法获取用户空间内存页面。如果快速方法不能获取所有请求的页面，它还可以尝试使用其他方法获取剩余的页面。这个函数会在访问用户空间内存时使用，例如在内核处理用户请求时。</p><h1 id="gup-pgd-range"><a href="#gup-pgd-range" class="headerlink" title="gup_pgd_range"></a>gup_pgd_range</h1><p>这是一个分析页全局目录（PGD）范围的函数，用于将虚拟地址范围映射到物理内存页面。这个函数被定义为 <code>static void gup_pgd_range</code>，它接收以下参数：</p><ol><li><code>unsigned long addr</code>：起始虚拟地址。</li><li><code>unsigned long end</code>：结束虚拟地址。</li><li><code>unsigned int flags</code>：标志，用于指定处理方式。</li><li><code>struct page **pages</code>：指向页面结构数组的指针。</li><li><code>int *nr</code>：指向存储当前已处理页面数量的整数的指针。</li></ol><p>函数首先通过调用 <code>pgd_offset(current-&gt;mm, addr)</code> 获取当前进程内存管理结构（<code>current-&gt;mm</code>）对应的页全局目录项指针 <code>pgdp</code>。接下来，它使用一个 <code>do-while</code> 循环遍历从 <code>addr</code> 到 <code>end</code> 的虚拟地址范围。</p><p>在循环中，首先获取当前 <code>pgdp</code> 指向的页全局目录项 <code>pgd</code>。然后调用 <code>pgd_addr_end(addr, end)</code> 计算下一个虚拟地址段的结束地址，存储在 <code>next</code> 变量中。</p><p>接下来，函数检查当前 <code>pgd</code> 是否为空（<code>pgd_none(pgd)</code>）。如果为空，函数直接返回。</p><p>如果当前 <code>pgd</code> 是一个巨大的页表项（<code>pgd_huge(pgd)</code>），函数调用 <code>gup_huge_pgd</code> 处理巨大页表项。否则，如果当前 <code>pgd</code> 是一个巨大页表目录（<code>is_hugepd(__hugepd(pgd_val(pgd)))</code>），函数调用 <code>gup_huge_pd</code> 处理巨大页表目录。最后，如果都不是上述情况，函数调用 <code>gup_p4d_range</code> 处理下一级页表。</p><p>在任何情况下，如果处理失败（返回值为 0），函数立即返回。否则，在循环条件中更新 <code>pgdp</code>、<code>addr</code> 和 <code>next</code>，并继续遍历虚拟地址范围。</p><p>总的来说，这个函数遍历虚拟地址范围，查找并处理与虚拟地址对应的物理内存页面。根据不同的页表项类型（巨大页表项、巨大页表目录等），它会调用不同的函数来处理这些项。</p><h1 id="gup-pte-range"><a href="#gup-pte-range" class="headerlink" title="gup_pte_range"></a>gup_pte_range</h1><p>这段代码实现了一个函数 <code>gup_pte_range()</code>，用于获取一个虚拟地址范围内的物理页框，并返回这些页框所对应的 <code>struct page</code> 数组和页框数量。下面是对这段代码的分析：</p><ol><li>首先定义了一些变量，包括 <code>pgmap</code>、<code>nr_start</code> 和 <code>ret</code> 等。其中 <code>pgmap</code> 是一个指向 <code>dev_pagemap</code> 结构体的指针，用于映射设备内存。<code>nr_start</code> 表示获取页框的起始数量，<code>ret</code> 表示函数的返回值。</li><li>然后通过 <code>pte_offset_map()</code> 函数获取一个 <code>pte_t</code> 类型的指针 <code>ptep</code>，该指针指向一个页表项（<code>pte</code>）的地址。同时将 <code>ptep</code> 赋值给 <code>ptem</code>，作为循环中的初始值。</li><li>使用一个 <code>do-while</code> 循环，遍历地址范围内的所有页表项。循环内部对每个页表项进行处理，具体操作如下：</li></ol><ul><li>使用 <code>gup_get_pte()</code> 函数获取页表项的值，并赋值给 <code>pte</code> 变量。</li><li>如果 <code>pte</code> 的保护位（protnone）被设置，说明这个页表项不可访问，直接跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>如果 <code>flags</code> 中包含 FOLL_WRITE 标志位，但 <code>pte</code> 中的写入权限被禁用，则也跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>如果 <code>pte</code> 是设备映射页，则进一步处理。如果 <code>flags</code> 中包含 FOLL_LONGTERM 标志位，则也跳转到 <code>pte_unmap</code> 标签处清理页面映射。否则，调用 <code>get_dev_pagemap()</code> 函数获取设备映射的 <code>dev_pagemap</code> 结构体，并将其赋值给 <code>pgmap</code> 变量。如果获取失败，则跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>如果 <code>pte</code> 是一个特殊页，则也跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>检查 <code>pte</code> 所对应的物理页框是否有效，如果无效则会触发 BUG，程序会停止运行。</li><li>调用 <code>pte_page()</code> 函数获取 <code>pte</code> 所对应的 <code>struct page</code> 结构体，并将其赋值给 <code>page</code> 变量。</li><li>如果 <code>page</code> 是一个复合页，则调用 <code>try_grab_compound_head()</code> 函数获取该页的头部页框，并将其赋值给 <code>head</code> 变量。如果获取失败，则跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>检查 <code>pte</code> 的值是否与 <code>ptep</code> 的值相等，如果不相等，则说明页表项已经被修改过，直接跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>检查 <code>compound_head(page)</code> 是否等于 <code>head</code>，如果不等于，则说明 <code>page</code> 不是一个有效的复合页，直接触发 BUG，程序会停止运行。</li><li>如果 <code>flags</code> 中包含 FOLL_PIN 标志位，则调用 <code>arch_make_page_accessible()</code> 函数使 <code>page</code> 可访问。如果操作失败，则调用 <code>unpin_user_page()</code> 函数解除页面锁定，并跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>调用 <code>SetPageReferenced()</code> 函数标记 <code>page</code> 已被引用过。</li><li>将 <code>page</code> 存储到 <code>pages</code> 数组中，并将 <code>nr</code> 的值增加 1。</li></ul><ol><li>循环结束后，如果函数没有被跳转到 <code>pte_unmap</code> 标签处，则将 <code>ret</code> 的值设为 1，表示函数执行成功。然后调用 <code>put_dev_pagemap()</code> 函数释放 <code>pgmap</code> 占用的资源，并调用 <code>pte_unmap()</code> 函数解除页面映射。</li><li>最后返回 <code>ret</code> 的值，表示函数执行结果的状态。</li></ol><h1 id="try-grab-compound-head"><a href="#try-grab-compound-head" class="headerlink" title="try_grab_compound_head"></a>try_grab_compound_head</h1><p>它的作用是尝试根据标志位(flags)增加一个给定页面（page）的引用计数。在此文件中，“grab”表示：根据标志位决定是使用FOLL_PIN还是FOLL_GET行为来增加页面的引用计数。</p><p>函数的参数如下：</p><ul><li><code>struct page *page</code>：要操作的页面。</li><li><code>int refs</code>：当前页面的引用计数。</li><li><code>unsigned int flags</code>：控制行为的标志位，包括FOLL_GET和FOLL_PIN。</li></ul><p>在这个函数中，FOLL_GET和FOLL_PIN（或者它们都没有）必须被设置，但不能同时设置。它们的含义如下：</p><ul><li>FOLL_GET：页面的引用计数将增加1。</li><li>FOLL_PIN：页面的引用计数将增加GUP_PIN_COUNTING_BIAS。</li></ul><p>根据flags的设置，函数会返回适当增加引用计数的头页面（head page），如果失败则返回NULL。如果没有设置FOLL_GET或FOLL_PIN，那么这被认为是失败，同时也可能是调用者的bug，因此还会发出警告。</p><p>函数的主体包含几个条件分支：</p><ol><li>如果设置了FOLL_GET，调用<code>try_get_compound_head</code>函数，参数为<code>page</code>和<code>refs</code>。</li><li>如果设置了FOLL_PIN，进行以下操作：<ul><li>检查是否同时设置了FOLL_LONGTERM，并且页面是CMA类型，如果是，则返回NULL。</li><li>如果页面的order大于1（由<code>hpage_pincount_available</code>函数检查），则将<code>refs</code>乘以GUP_PIN_COUNTING_BIAS。</li><li>调用<code>try_get_compound_head</code>函数，参数为<code>page</code>和<code>refs</code>。</li><li>如果页面的order大于1，调用<code>hpage_pincount_add</code>函数增加页面的pin计数。</li><li>更新节点状态（<code>mod_node_page_state</code>）。</li><li>返回适当增加引用计数的头页面。</li></ul></li><li>如果既没有设置FOLL_GET，也没有设置FOLL_PIN，发出警告，并返回NULL。</li></ol><h1 id="try-get-compound-head"><a href="#try-get-compound-head" class="headerlink" title="try_get_compound_head"></a>try_get_compound_head</h1><p>这是一个静态内联函数，返回一个<code>struct page</code>类型的指针，并接受两个参数：</p><ol><li><code>struct page *page</code> - 一个指向<code>struct page</code>类型的指针，表示我们要获取其头部的复合页。</li><li><code>int refs</code> - 一个整数，表示我们希望增加的引用计数。</li></ol><p><code>try_get_compound_head()</code>函数的目的是获取复合页的头部，并将其引用计数适当地增加。如果成功，函数返回头部的指针，否则返回<code>NULL</code>。</p>]]></content>
      
      
      <categories>
          
          <category> linux学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
