<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sanli的博客之家</title>
  
  <subtitle>享受编程</subtitle>
  <link href="https://sanli-b.com.cn/atom.xml" rel="self"/>
  
  <link href="https://sanli-b.com.cn/"/>
  <updated>2023-09-01T05:18:43.965Z</updated>
  <id>https://sanli-b.com.cn/</id>
  
  <author>
    <name>sanli</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux内存管理模块一些函数介绍</title>
    <link href="https://sanli-b.com.cn/posts/35092.html"/>
    <id>https://sanli-b.com.cn/posts/35092.html</id>
    <published>2023-09-01T03:02:35.000Z</published>
    <updated>2023-09-01T05:18:43.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>本文介绍了internal_get_user_pages_fast、gup_pgd_range、gup_pte_range、try_grab_compound_head</p><h1 id="internal-get-user-pages-fast"><a href="#internal-get-user-pages-fast" class="headerlink" title="internal_get_user_pages_fast"></a>internal_get_user_pages_fast</h1><p>这是一个用于获取用户空间页面的函数，函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">internal_get_user_pages_fast</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start, <span class="type">int</span> nr_pages,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">int</span> gup_flags,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> page **pages)</span></span><br></pre></td></tr></table></figure><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul><li><code>start</code>：要获取的用户空间起始地址。</li><li><code>nr_pages</code>：要获取的页面数量。</li><li><code>gup_flags</code>：用于指定页面特性和行为的标志。</li><li><code>pages</code>：指向一个<code>struct page</code>指针的数组，存储获取到的页面的指针。</li></ul><p>函数返回获取到的页面数量，或者在出错时返回负的错误代码。</p><h3 id="函数的主要步骤如下："><a href="#函数的主要步骤如下：" class="headerlink" title="函数的主要步骤如下："></a>函数的主要步骤如下：</h3><ol><li>进行参数检查，确保传入的<code>gup_flags</code>是合法的组合。</li><li>如果设置了<code>FOLL_PIN</code>标记，将当前进程的内存管理结构中的<code>has_pinned</code>原子变量设为1。</li><li>如果没有设置<code>FOLL_FAST_ONLY</code>标记，使用<code>might_lock_read</code>宏提示可能会对<code>mmap_lock</code>读锁进行加锁。</li><li>计算起始地址、结束地址和地址范围长度，确保它们是有效的。</li><li>禁用中断，阻止页面表页面在操作期间被释放。</li><li>如果启用了<code>CONFIG_HAVE_FAST_GUP</code>配置，并且允许快速GUP（Get User Pages）操作，则调用<code>gup_pgd_range</code>函数获取页面，将获取到的页面数量存储在<code>nr_pinned</code>变量中。</li><li>如果没有获取到所有请求的页面并且没有设置<code>FOLL_FAST_ONLY</code>标记，则尝试使用<code>__gup_longterm_unlocked</code>函数获取剩余的页面。</li><li>根据已获取页面的数量和剩余页面尝试的结果，返回最终结果。</li></ol><p>这个函数的主要作用是尝试使用快速GUP（Get User Pages）方法获取用户空间内存页面。如果快速方法不能获取所有请求的页面，它还可以尝试使用其他方法获取剩余的页面。这个函数会在访问用户空间内存时使用，例如在内核处理用户请求时。</p><h1 id="gup-pgd-range"><a href="#gup-pgd-range" class="headerlink" title="gup_pgd_range"></a>gup_pgd_range</h1><p>这是一个分析页全局目录（PGD）范围的函数，用于将虚拟地址范围映射到物理内存页面。这个函数被定义为 <code>static void gup_pgd_range</code>，它接收以下参数：</p><ol><li><code>unsigned long addr</code>：起始虚拟地址。</li><li><code>unsigned long end</code>：结束虚拟地址。</li><li><code>unsigned int flags</code>：标志，用于指定处理方式。</li><li><code>struct page **pages</code>：指向页面结构数组的指针。</li><li><code>int *nr</code>：指向存储当前已处理页面数量的整数的指针。</li></ol><p>函数首先通过调用 <code>pgd_offset(current-&gt;mm, addr)</code> 获取当前进程内存管理结构（<code>current-&gt;mm</code>）对应的页全局目录项指针 <code>pgdp</code>。接下来，它使用一个 <code>do-while</code> 循环遍历从 <code>addr</code> 到 <code>end</code> 的虚拟地址范围。</p><p>在循环中，首先获取当前 <code>pgdp</code> 指向的页全局目录项 <code>pgd</code>。然后调用 <code>pgd_addr_end(addr, end)</code> 计算下一个虚拟地址段的结束地址，存储在 <code>next</code> 变量中。</p><p>接下来，函数检查当前 <code>pgd</code> 是否为空（<code>pgd_none(pgd)</code>）。如果为空，函数直接返回。</p><p>如果当前 <code>pgd</code> 是一个巨大的页表项（<code>pgd_huge(pgd)</code>），函数调用 <code>gup_huge_pgd</code> 处理巨大页表项。否则，如果当前 <code>pgd</code> 是一个巨大页表目录（<code>is_hugepd(__hugepd(pgd_val(pgd)))</code>），函数调用 <code>gup_huge_pd</code> 处理巨大页表目录。最后，如果都不是上述情况，函数调用 <code>gup_p4d_range</code> 处理下一级页表。</p><p>在任何情况下，如果处理失败（返回值为 0），函数立即返回。否则，在循环条件中更新 <code>pgdp</code>、<code>addr</code> 和 <code>next</code>，并继续遍历虚拟地址范围。</p><p>总的来说，这个函数遍历虚拟地址范围，查找并处理与虚拟地址对应的物理内存页面。根据不同的页表项类型（巨大页表项、巨大页表目录等），它会调用不同的函数来处理这些项。</p><h1 id="gup-pte-range"><a href="#gup-pte-range" class="headerlink" title="gup_pte_range"></a>gup_pte_range</h1><p>这段代码实现了一个函数 <code>gup_pte_range()</code>，用于获取一个虚拟地址范围内的物理页框，并返回这些页框所对应的 <code>struct page</code> 数组和页框数量。下面是对这段代码的分析：</p><ol><li>首先定义了一些变量，包括 <code>pgmap</code>、<code>nr_start</code> 和 <code>ret</code> 等。其中 <code>pgmap</code> 是一个指向 <code>dev_pagemap</code> 结构体的指针，用于映射设备内存。<code>nr_start</code> 表示获取页框的起始数量，<code>ret</code> 表示函数的返回值。</li><li>然后通过 <code>pte_offset_map()</code> 函数获取一个 <code>pte_t</code> 类型的指针 <code>ptep</code>，该指针指向一个页表项（<code>pte</code>）的地址。同时将 <code>ptep</code> 赋值给 <code>ptem</code>，作为循环中的初始值。</li><li>使用一个 <code>do-while</code> 循环，遍历地址范围内的所有页表项。循环内部对每个页表项进行处理，具体操作如下：</li></ol><ul><li>使用 <code>gup_get_pte()</code> 函数获取页表项的值，并赋值给 <code>pte</code> 变量。</li><li>如果 <code>pte</code> 的保护位（protnone）被设置，说明这个页表项不可访问，直接跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>如果 <code>flags</code> 中包含 FOLL_WRITE 标志位，但 <code>pte</code> 中的写入权限被禁用，则也跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>如果 <code>pte</code> 是设备映射页，则进一步处理。如果 <code>flags</code> 中包含 FOLL_LONGTERM 标志位，则也跳转到 <code>pte_unmap</code> 标签处清理页面映射。否则，调用 <code>get_dev_pagemap()</code> 函数获取设备映射的 <code>dev_pagemap</code> 结构体，并将其赋值给 <code>pgmap</code> 变量。如果获取失败，则跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>如果 <code>pte</code> 是一个特殊页，则也跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>检查 <code>pte</code> 所对应的物理页框是否有效，如果无效则会触发 BUG，程序会停止运行。</li><li>调用 <code>pte_page()</code> 函数获取 <code>pte</code> 所对应的 <code>struct page</code> 结构体，并将其赋值给 <code>page</code> 变量。</li><li>如果 <code>page</code> 是一个复合页，则调用 <code>try_grab_compound_head()</code> 函数获取该页的头部页框，并将其赋值给 <code>head</code> 变量。如果获取失败，则跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>检查 <code>pte</code> 的值是否与 <code>ptep</code> 的值相等，如果不相等，则说明页表项已经被修改过，直接跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>检查 <code>compound_head(page)</code> 是否等于 <code>head</code>，如果不等于，则说明 <code>page</code> 不是一个有效的复合页，直接触发 BUG，程序会停止运行。</li><li>如果 <code>flags</code> 中包含 FOLL_PIN 标志位，则调用 <code>arch_make_page_accessible()</code> 函数使 <code>page</code> 可访问。如果操作失败，则调用 <code>unpin_user_page()</code> 函数解除页面锁定，并跳转到 <code>pte_unmap</code> 标签处清理页面映射。</li><li>调用 <code>SetPageReferenced()</code> 函数标记 <code>page</code> 已被引用过。</li><li>将 <code>page</code> 存储到 <code>pages</code> 数组中，并将 <code>nr</code> 的值增加 1。</li></ul><ol><li>循环结束后，如果函数没有被跳转到 <code>pte_unmap</code> 标签处，则将 <code>ret</code> 的值设为 1，表示函数执行成功。然后调用 <code>put_dev_pagemap()</code> 函数释放 <code>pgmap</code> 占用的资源，并调用 <code>pte_unmap()</code> 函数解除页面映射。</li><li>最后返回 <code>ret</code> 的值，表示函数执行结果的状态。</li></ol><h1 id="try-grab-compound-head"><a href="#try-grab-compound-head" class="headerlink" title="try_grab_compound_head"></a>try_grab_compound_head</h1><p>它的作用是尝试根据标志位(flags)增加一个给定页面（page）的引用计数。在此文件中，“grab”表示：根据标志位决定是使用FOLL_PIN还是FOLL_GET行为来增加页面的引用计数。</p><p>函数的参数如下：</p><ul><li><code>struct page *page</code>：要操作的页面。</li><li><code>int refs</code>：当前页面的引用计数。</li><li><code>unsigned int flags</code>：控制行为的标志位，包括FOLL_GET和FOLL_PIN。</li></ul><p>在这个函数中，FOLL_GET和FOLL_PIN（或者它们都没有）必须被设置，但不能同时设置。它们的含义如下：</p><ul><li>FOLL_GET：页面的引用计数将增加1。</li><li>FOLL_PIN：页面的引用计数将增加GUP_PIN_COUNTING_BIAS。</li></ul><p>根据flags的设置，函数会返回适当增加引用计数的头页面（head page），如果失败则返回NULL。如果没有设置FOLL_GET或FOLL_PIN，那么这被认为是失败，同时也可能是调用者的bug，因此还会发出警告。</p><p>函数的主体包含几个条件分支：</p><ol><li>如果设置了FOLL_GET，调用<code>try_get_compound_head</code>函数，参数为<code>page</code>和<code>refs</code>。</li><li>如果设置了FOLL_PIN，进行以下操作：<ul><li>检查是否同时设置了FOLL_LONGTERM，并且页面是CMA类型，如果是，则返回NULL。</li><li>如果页面的order大于1（由<code>hpage_pincount_available</code>函数检查），则将<code>refs</code>乘以GUP_PIN_COUNTING_BIAS。</li><li>调用<code>try_get_compound_head</code>函数，参数为<code>page</code>和<code>refs</code>。</li><li>如果页面的order大于1，调用<code>hpage_pincount_add</code>函数增加页面的pin计数。</li><li>更新节点状态（<code>mod_node_page_state</code>）。</li><li>返回适当增加引用计数的头页面。</li></ul></li><li>如果既没有设置FOLL_GET，也没有设置FOLL_PIN，发出警告，并返回NULL。</li></ol><h1 id="try-get-compound-head"><a href="#try-get-compound-head" class="headerlink" title="try_get_compound_head"></a>try_get_compound_head</h1><p>这是一个静态内联函数，返回一个<code>struct page</code>类型的指针，并接受两个参数：</p><ol><li><code>struct page *page</code> - 一个指向<code>struct page</code>类型的指针，表示我们要获取其头部的复合页。</li><li><code>int refs</code> - 一个整数，表示我们希望增加的引用计数。</li></ol><p><code>try_get_compound_head()</code>函数的目的是获取复合页的头部，并将其引用计数适当地增加。如果成功，函数返回头部的指针，否则返回<code>NULL</code>。</p>]]></content>
    
    
    <summary type="html">本文介绍了internal_get_user_pages_fast、gup_pgd_range、gup_pte_range、try_grab_compound_head</summary>
    
    
    
    <category term="linux学习" scheme="https://sanli-b.com.cn/categories/linux%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="linux" scheme="https://sanli-b.com.cn/tags/linux/"/>
    
    <category term="内存管理" scheme="https://sanli-b.com.cn/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>试水+1</title>
    <link href="https://sanli-b.com.cn/posts/48250.html"/>
    <id>https://sanli-b.com.cn/posts/48250.html</id>
    <published>2023-08-28T13:31:45.000Z</published>
    <updated>2023-09-01T02:49:27.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure --kernel-version=$(<span class="built_in">uname</span> -r) --kernel-sources=/lib/modules/$(<span class="built_in">uname</span> -r)/build --with-core-mod --with-user_mad-mod --with-user_access-mod --with-addr_trans-mod --with-mlxfw-mod --with-mlx5-mod --with-ipoib-mod --with-mlxdevm-mod --with-srp-mod --with-iser-mod --with-isert-mod --with-gds --with-njobs=16 --with-odp</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line">/etc/init.d/openibd restart</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">sudo insmod remap.ko</span><br><span class="line">sudo rmmod remap.ko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动frp</span></span><br><span class="line">sudo systemctl start frpc</span><br><span class="line"></span><br><span class="line">sudo find -name MLNX_OFED_LINUX*</span><br></pre></td></tr></table></figure><h4 id="重启驱动"><a href="#重启驱动" class="headerlink" title="重启驱动"></a>重启驱动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/openibd restart</span><br></pre></td></tr></table></figure><h4 id="看页错误的数量"><a href="#看页错误的数量" class="headerlink" title="看页错误的数量"></a>看页错误的数量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps -o maj_flt -o min_flt -p `ps -e|grep rdma-rc-example|awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">ps -o maj_flt -o min_flt -p `ps -e|grep pftest|awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line"></span><br><span class="line">ps -o maj_flt -o min_flt -p `ps -e|grep mtt|awk &#x27;&#123;print $1&#125;&#x27;`</span><br></pre></td></tr></table></figure><h4 id="实时监控dmesg日志输出"><a href="#实时监控dmesg日志输出" class="headerlink" title="实时监控dmesg日志输出"></a><strong>实时监控dmesg日志输出</strong></h4><p>tail -f &#x2F;var&#x2F;log&#x2F;dmesg</p><h4 id="查看缺页"><a href="#查看缺页" class="headerlink" title="查看缺页"></a>查看缺页</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o maj_flt -o min_flt -p `ps -e|grep m|awk &#x27;&#123;print $1&#125;&#x27;`</span><br></pre></td></tr></table></figure><p><img src="/img/image-20230128151544391.png" alt="image-20230128151544391"></p><h4 id="内核打印"><a href="#内核打印" class="headerlink" title="内核打印"></a>内核打印</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_ALERT &quot;pfn %s:\n&quot;, prefix);</span><br><span class="line">cd /home/zxy/lxt_test_zxy</span><br><span class="line">./rdma-rc-example -p 8001 -d mlx5_0 -i 1 -g fe80:0000:0000:0000:0215:5dff:fe03:01f6</span><br></pre></td></tr></table></figure><h1 id="开启iommu"><a href="#开启iommu" class="headerlink" title="开启iommu"></a>开启iommu</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/default/grub  </span><br><span class="line">  GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rhgb quiet iommu=pt intel_iommu=on&quot;</span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line">sudo update-grub </span><br><span class="line">检查：</span><br><span class="line">dmesg | grep -E &quot;DMAR|IOMMU&quot;</span><br><span class="line">//[    0.036018] DMAR: IOMMU enabled</span><br><span class="line">cat /proc/cmdline</span><br><span class="line">//BOOT_IMAGE=/vmlinuz-5.9.7 root=/dev/mapper/ubuntu--vg-root ro iommu=pt intel_iommu=on</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;驱动安装&quot;&gt;&lt;a href=&quot;#驱动安装&quot; class=&quot;headerlink&quot; title=&quot;驱动安装&quot;&gt;&lt;/a&gt;驱动安装&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre</summary>
      
    
    
    
    <category term="linux学习" scheme="https://sanli-b.com.cn/categories/linux%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="linux" scheme="https://sanli-b.com.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sanli-b.com.cn/posts/16107.html"/>
    <id>https://sanli-b.com.cn/posts/16107.html</id>
    <published>2023-07-10T13:53:48.190Z</published>
    <updated>2023-08-29T08:02:02.064Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
